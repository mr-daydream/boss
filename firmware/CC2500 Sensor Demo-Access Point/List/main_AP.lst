###############################################################################
#
# IAR C/C++ Compiler V7.10.1.973/W32 for MSP430           30/Apr/2017  00:53:41
# Copyright 1996-2017 IAR Systems AB.
# Evaluation license - IAR Embedded Workbench for Texas Instruments MSP430, Evaluation Version 7.10
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430
#    Source file   =  
#        C:\Users\mscottnelson\Documents\GitHub\boss\firmware\Applications\main_AP.c
#    Command line  =  
#        -f C:\Users\MSCOTT~1\AppData\Local\Temp\EWC0B2.tmp (-f
#        C:\Users\mscottnelson\Documents\GitHub\boss\firmware\Configuration\smpl_config_AP.dat
#        (-DNUM_CONNECTIONS=8 -DSIZE_INFRAME_Q=6 -DSIZE_OUTFRAME_Q=2
#        "-DTHIS_DEVICE_ADDRESS={0x78, 0x56, 0x34, 0x12}" -DACCESS_POINT
#        -DAP_IS_DATA_HUB -DNUM_STORE_AND_FWD_CLIENTS=3
#        -DSTARTUP_JOINCONTEXT_ON) -f
#        C:\Users\mscottnelson\Documents\GitHub\boss\firmware\Configuration\smpl_nwk_config.dat
#        (-DMAX_HOPS=3 -DMAX_HOPS_FROM_AP=1 -DMAX_NWK_PAYLOAD=9
#        -DMAX_APP_PAYLOAD=10 -DDEFAULT_LINK_TOKEN=0x01020304
#        -DDEFAULT_JOIN_TOKEN=0x05060708 -DEXTENDED_API -DSW_TIMER)
#        C:\Users\mscottnelson\Documents\GitHub\boss\firmware\Applications\main_AP.c
#        -D MRFI_CC2500 -lcN
#        "C:\Users\mscottnelson\Documents\GitHub\boss\firmware\CC2500 Sensor
#        Demo-Access Point\List" -o
#        "C:\Users\mscottnelson\Documents\GitHub\boss\firmware\CC2500 Sensor
#        Demo-Access Point\Obj" --debug -D__MSP430F2274__ -e --double=32 --clib
#        -I
#        C:\Users\mscottnelson\Documents\GitHub\boss\firmware\Components\bsp\
#        -I
#        C:\Users\mscottnelson\Documents\GitHub\boss\firmware\Components\bsp\drivers\
#        -I
#        C:\Users\mscottnelson\Documents\GitHub\boss\firmware\Components\bsp\boards\EZ430RF\
#        -I
#        C:\Users\mscottnelson\Documents\GitHub\boss\firmware\Components\mrfi\
#        -I
#        C:\Users\mscottnelson\Documents\GitHub\boss\firmware\Components\SimpliciTI\nwk\
#        -I
#        C:\Users\mscottnelson\Documents\GitHub\boss\firmware\Components\SimpliciTI\nwk_applications\
#        -Ohz --require_prototypes --hw_workaround=nop_after_lpm)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\mscottnelson\Documents\GitHub\boss\firmware\CC2500 Sensor
#        Demo-Access Point\List\main_AP.lst
#    Object file   =  
#        C:\Users\mscottnelson\Documents\GitHub\boss\firmware\CC2500 Sensor
#        Demo-Access Point\Obj\main_AP.r43
#
###############################################################################

C:\Users\mscottnelson\Documents\GitHub\boss\firmware\Applications\main_AP.c
      1          //
      2          // Bed Occupancy Sensor Suite - Access Point (BOSS-AP) main_AP.c
      3          // by SH, MESN, JC, LS for Baltimore Hackathon project BOSS.
      4          // adapted from TI ez430-RF2500 Sensor Demo project.
      5          // 4/29/2017
      6          //
      7          
      8          
      9          //******************************************************************************
     10          // THIS PROGRAM IS PROVIDED "AS IS". TI MAKES NO WARRANTIES OR
     11          // REPRESENTATIONS, EITHER EXPRESS, IMPLIED OR STATUTORY,
     12          // INCLUDING ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
     13          // FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR
     14          // COMPLETENESS OF RESPONSES, RESULTS AND LACK OF NEGLIGENCE.
     15          // TI DISCLAIMS ANY WARRANTY OF TITLE, QUIET ENJOYMENT, QUIET
     16          // POSSESSION, AND NON-INFRINGEMENT OF ANY THIRD PARTY
     17          // INTELLECTUAL PROPERTY RIGHTS WITH REGARD TO THE PROGRAM OR
     18          // YOUR USE OF THE PROGRAM.
     19          //
     20          // IN NO EVENT SHALL TI BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
     21          // CONSEQUENTIAL OR INDIRECT DAMAGES, HOWEVER CAUSED, ON ANY
     22          // THEORY OF LIABILITY AND WHETHER OR NOT TI HAS BEEN ADVISED
     23          // OF THE POSSIBILITY OF SUCH DAMAGES, ARISING IN ANY WAY OUT
     24          // OF THIS AGREEMENT, THE PROGRAM, OR YOUR USE OF THE PROGRAM.
     25          // EXCLUDED DAMAGES INCLUDE, BUT ARE NOT LIMITED TO, COST OF
     26          // REMOVAL OR REINSTALLATION, COMPUTER TIME, LABOR COSTS, LOSS
     27          // OF GOODWILL, LOSS OF PROFITS, LOSS OF SAVINGS, OR LOSS OF
     28          // USE OR INTERRUPTION OF BUSINESS. IN NO EVENT WILL TI'S
     29          // AGGREGATE LIABILITY UNDER THIS AGREEMENT OR ARISING OUT OF
     30          // YOUR USE OF THE PROGRAM EXCEED FIVE HUNDRED DOLLARS
     31          // (U.S.$500).
     32          //
     33          // Unless otherwise stated, the Program written and copyrighted
     34          // by Texas Instruments is distributed as "freeware".  You may,
     35          // only under TI's copyright in the Program, use and modify the
     36          // Program without any charge or restriction.  You may
     37          // distribute to third parties, provided that you transfer a
     38          // copy of this license to the third party and the third party
     39          // agrees to these terms by its first use of the Program. You
     40          // must reproduce the copyright notice and any other legend of
     41          // ownership on each copy or partial copy, of the Program.
     42          //
     43          // You acknowledge and agree that the Program contains
     44          // copyrighted material, trade secrets and other TI proprietary
     45          // information and is protected by copyright laws,
     46          // international copyright treaties, and trade secret laws, as
     47          // well as other intellectual property laws.  To protect TI's
     48          // rights in the Program, you agree not to decompile, reverse
     49          // engineer, disassemble or otherwise translate any object code
     50          // versions of the Program to a human-readable form.  You agree
     51          // that in no event will you alter, remove or destroy any
     52          // copyright notice included in the Program.  TI reserves all
     53          // rights not specifically granted under this license. Except
     54          // as specifically provided herein, nothing in this agreement
     55          // shall be construed as conferring by implication, estoppel,
     56          // or otherwise, upon you, any license or other right under any
     57          // TI patents, copyrights or trade secrets.
     58          //
     59          // You may not use the Program in non-TI devices.
     60          //
     61          //******************************************************************************
     62          //   eZ430-RF2500 Temperature Sensor Access Point
     63          //
     64          //   Description: This is the Access Point software for the eZ430-2500RF
     65          //                Temperature Sensing demo
     66          //
     67          //
     68          //   Z. Shivers
     69          //   Version    1.05
     70          //   Texas Instruments, Inc
     71          //   July 2010
     72          //     IAR Embedded Workbench Kickstart (Version: 5.10.4)
     73          //     Code Composer Studio (Version 4.1.2.00027)
     74          //******************************************************************************
     75          //Change Log:
     76          //******************************************************************************
     77          //Version:  1.05
     78          //Comments: Added support for various baud rates dependent on CPU frequencies
     79          //Version:  1.04
     80          //Comments: Added support for SimpliciTI 1.1.1
     81          //          Replaced delays with __delay_cycles() instrinsic
     82          //          Added more comments
     83          //Version:  1.03
     84          //Comments: Added support for SimpliciTI 1.1.0
     85          //          Added support for Code Composer Studio
     86          //          Added security (Enabled with -DSMPL_SECURE in smpl_nwk_config.dat)
     87          //          Added acknowledgement (Enabled with -DAPP_AUTO_ACK in smpl_nwk_config.dat)
     88          //          Based the modifications on the AP_as_Data_Hub example code
     89          //Version:  1.02
     90          //Comments: Changed Port toggling to abstract method
     91          //          Removed ToggleLED
     92          //          Fixed comment typos/errors
     93          //          Changed startup string to 1.02
     94          //Version:  1.01
     95          //Comments: Added support for SimpliciTI 1.0.3
     96          //          Changed RSSI read method
     97          //          Added 3 digit temperature output for 100+F
     98          //          Changed startup string to 1.01
     99          //Version:  1.00
    100          //Comments: Initial Release Version
    101          //******************************************************************************
    102          #include <string.h>
    103          #include "bsp.h"
    104          #include "mrfi.h"
    105          #include "bsp_leds.h"
    106          #include "bsp_buttons.h"
    107          #include "nwk_types.h"
    108          #include "nwk_api.h"
    109          #include "nwk_frame.h"
    110          #include "nwk.h"
    111          #include "virtual_com_cmds.h"
    112          #include <stdio.h>
    113          
    114          /****************** COMMENTS ON ASYNC LISTEN APPLICATION ***********************
    115          Summary:
    116            This AP build includes implementation of an unknown number of end device peers
    117            in addition to AP functionality. In this scenario all End Devices establish a
    118            link to the AP and only to the AP. The AP acts as a data hub. All End Device
    119            peers are on the AP and not on other distinct ED platforms.
    120          
    121            There is still a limit to the number of peers supported on the AP that is
    122            defined by the macro NUM_CONNECTIONS. The AP will support NUM_CONNECTIONS or
    123            fewer peers but the exact number does not need to be known at build time.
    124          
    125            In this special but common scenario SimpliciTI restricts each End Device
    126            object to a single connection to the AP. If multiple logical connections are
    127            required these must be accommodated by supporting contexts in the application
    128            payload itself.
    129          
    130          Solution overview:
    131            When a new peer connection is required the AP main loop must be notified. In
    132            essence the main loop polls a semaphore to know whether to begin listening for
    133            a peer Link request from a new End Device. There are two solutions: automatic
    134            notification and external notification. The only difference between the
    135            automatic notification solution and the external notification solution is how
    136            the listen semaphore is set. In the external notification solution the
    137            sempahore is set by the user when the AP is stimulated for example by a button
    138            press or a commend over a serial link. In the automatic scheme the
    139            notification is accomplished as a side effect of a new End Device joining.
    140          
    141            The Rx callback must be implemented. When the callback is invoked with a
    142            non-zero Link ID the handler could set a semaphore that alerts the main work
    143            loop that a SMPL_Receive() can be executed successfully on that Link ID.
    144          
    145            If the callback conveys an argument (LinkID) of 0 then a new device has joined
    146            the network. A SMPL_LinkListen() should be executed.
    147          
    148            Whether the joining device supports ED objects is indirectly inferred on the
    149            joining device from the setting of the NUM_CONNECTIONS macro. The value of
    150            this macro should be non-zero only if ED objects exist on the device. This
    151            macro is always non-zero for ED-only devices. But Range Extenders may or may
    152            not support ED objects. The macro should be be set to 0 for REs that do not
    153            also support ED objects. This prevents the Access Point from reserving
    154            resources for a joinng device that does not support any End Device Objects and
    155            it prevents the AP from executing a SMPL_LinkListen(). The Access Point will
    156            not ever see a Link frame if the joining device does not support any
    157            connections.
    158          
    159            Each joining device must execute a SMPL_Link() after receiving the join reply
    160            from the Access Point. The Access Point will be listening.
    161          
    162          ******************* END COMMENTS ON ASYNC LISTEN APPLICATION ******************/
    163          
    164          /******  THIS SOURCE FILE REPRESENTS THE AUTOMATIC NOTIFICATION SOLUTION ******/
    165          
    166          /*------------------------------------------------------------------------------
    167           * Prototypes
    168           *----------------------------------------------------------------------------*/
    169          /* Frequency Agility helper functions */
    170          static void    checkChangeChannel(void);
    171          static void    changeChannel(void);
    172          
    173          __interrupt void ADC10_ISR(void);
    174          __interrupt void Timer_A (void);
    175          
    176          /*------------------------------------------------------------------------------
    177           * Globals
    178           *----------------------------------------------------------------------------*/
    179          /* reserve space for the maximum possible peer Link IDs */
    180          static linkID_t sLID[NUM_CONNECTIONS] = {0};
    181          static uint8_t  sNumCurrentPeers = 0;
    182          
    183          /* callback handler */
    184          static uint8_t sCB(linkID_t);
    185          
    186          /* received message handler */
    187          static void processMessage(linkID_t, uint8_t *, uint8_t);
    188          
    189          /* work loop semaphores */
    190          static volatile uint8_t sPeerFrameSem = 0;
    191          static volatile uint8_t sJoinSem = 0;
    192          static volatile uint8_t sSelfMeasureSem = 0;
    193          
    194          /* blink LEDs when channel changes... */
    195          static volatile uint8_t sBlinky = 0;
    196          
    197          /* data for terminal output */
    198          //const char splash[] = {"\r\n--------------------------------------------------  \r\n     ****\r\n     ****           eZ430-RF2500(BC)\r\n     ******o****    Bed Count Sensor Network\r\n********_///_****   Copyright 2009\r\n ******/_//_/*****  Texas Instruments Incorporated\r\n  ** ***(__/*****   All rights reserved.\r\n      *********     SimpliciTI1.1.1\r\n       *****\r\n        ***\r\n--------------------------------------------------\r\n"};
    199          const char splash[] = {"\r\n________________________________________________________________________________________________\n\nez430-RF2500(BC) - Bed Count Sensor Network AP\n\nBased upon Texas Instruments ez430-RF2500 Wireless Sensor Demo\n\n(c) Tek Terrain LLC, 2017\n\n________________________________________________________________________________________________\r\n\n"};
    200          volatile int * tempOffset = (int *)0x10F4;
    201          
    202          /*------------------------------------------------------------------------------
    203           * Frequency Agility support (interference detection)
    204           *----------------------------------------------------------------------------*/
    205          #ifdef FREQUENCY_AGILITY
    206          
    207          #define INTERFERNCE_THRESHOLD_DBM (-70)
    208          #define SSIZE    25
    209          #define IN_A_ROW  3
    210          static int8_t  sSample[SSIZE];
    211          static uint8_t sChannel = 0;
    212          
    213          #endif  /* FREQUENCY_AGILITY */
    214          
    215          /*------------------------------------------------------------------------------
    216           * Main
    217           *----------------------------------------------------------------------------*/
    218          void main (void)
    219          {
    220            bspIState_t intState;
    221          
    222          #ifdef FREQUENCY_AGILITY
    223            memset(sSample, 0x0, sizeof(sSample));
    224          #endif
    225          
    226            /* Initialize board */
    227            BSP_Init();
    228          
    229            /* Initialize TimerA and oscillator */
    230            BCSCTL3 |= LFXT1S_2;                      // LFXT1 = VLO
    231            TACCTL0 = CCIE;                           // TACCR0 interrupt enabled
    232            TACCR0 = 12000;                           // ~1 second
    233            TACTL = TASSEL_1 + MC_1;                  // ACLK, upmode
    234          
    235            /* Initialize serial port */
    236            COM_Init();
    237          
    238            //Transmit splash screen and network init notification
    239            TXString( (char*)splash, sizeof splash);
    240            TXString( "\r\nInitializing Network....", 26 );
    241          
    242            SMPL_Init(sCB);
    243          
    244            // network initialized
    245            TXString( "Done\r\n", 6);
    246          
    247            /* green and red LEDs on solid to indicate waiting for a Join. */
    248            BSP_TURN_ON_LED1();
    249            BSP_TURN_ON_LED2();
    250          
    251            /* main work loop */
    252            while (1)
    253            {
    254              /* Wait for the Join semaphore to be set by the receipt of a Join frame from
    255               * a device that supports an End Device.
    256               *
    257               * An external method could be used as well. A button press could be connected
    258               * to an ISR and the ISR could set a semaphore that is checked by a function
    259               * call here, or a command shell running in support of a serial connection
    260               * could set a semaphore that is checked by a function call.
    261               */
    262              if (sJoinSem && (sNumCurrentPeers < NUM_CONNECTIONS))
    263              {
    264                /* listen for a new connection */
    265                while (1)
    266                {
    267                  if (SMPL_SUCCESS == SMPL_LinkListen(&sLID[sNumCurrentPeers]))
    268                  {
    269                    break;
    270                  }
    271                  /* Implement fail-to-link policy here. otherwise, listen again. */
    272                }
    273          
    274                sNumCurrentPeers++;
    275          
    276                BSP_ENTER_CRITICAL_SECTION(intState);
    277                sJoinSem--;
    278                BSP_EXIT_CRITICAL_SECTION(intState);
    279              }
    280          
    281          
    282              // if it is time to measure our own temperature...
    283              if(sSelfMeasureSem)
    284              {
    285                char msg [7];
    286                char addr[] = {"HUB0"};
    287                char rssi[] = {"000"};
    288                int degC, volt, bend;
    289                volatile long temp;
    290                int results[6];
    291          ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    292                /* Get temperature */
    293                ADC10CTL1 = INCH_10 + ADC10DIV_4;       // Temp Sensor ADC10CLK/5
    294                ADC10CTL0 = SREF_1 + ADC10SHT_3 + REFON + ADC10ON + ADC10IE + ADC10SR;
    295                /* Allow ref voltage to settle for at least 30us (30us * 8MHz = 240 cycles)
    296                 * See SLAS504D for settling time spec
    297                 */
    298                __delay_cycles(240);
    299                ADC10CTL0 |= ENC + ADC10SC;             // Sampling and conversion start
    300                __bis_SR_register(CPUOFF + GIE);        // LPM0 with interrupts enabled
    301                results[0] = ADC10MEM;                  // Retrieve result
    302          
    303                ADC10CTL0 &= ~ENC;
    304          ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    305                /* Get voltage */
    306                ADC10CTL1 = INCH_11;                     // AVcc/2
    307                ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE + REF2_5V;
    308                __delay_cycles(240);
    309                ADC10CTL0 |= ENC + ADC10SC;             // Sampling and conversion start
    310                __bis_SR_register(CPUOFF + GIE);        // LPM0 with interrupts enabled
    311                results[1] = ADC10MEM;                  // Retrieve result
    312          
    313                /* Stop and turn off ADC */
    314                ADC10CTL0 &= ~ENC;
    315                ADC10CTL0 &= ~(REFON + ADC10ON);
    316            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    317          //////////////////////////////////////////////////////////////////////////////////////////////////
    318          /* SH Get voltage from Channel A0 (P2.0/ACLK/A0/OA010) */     
    319          // SH add in results channel 2 for flex resistor sensor with 25K (nominal), 45K (minimum), 125K(max) bend
    320               
    321                ADC10CTL1 = INCH_0;                     // selects channel 0 
    322                ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE + REF2_5V;
    323                __delay_cycles(240);
    324                ADC10CTL0 |= ENC + ADC10SC;             // Sampling and conversion start
    325                __bis_SR_register(CPUOFF + GIE);        // LPM0 with interrupts enabled
    326                results[2] = ADC10MEM;                  // Retrieve result
    327                
    328                /* Stop and turn off ADC */
    329                ADC10CTL0 &= ~ENC;
    330                ADC10CTL0 &= ~(REFON + ADC10ON);
    331              
    332          //////////////////////////////////////////////////////////////////////////////////////////////////    
    333          
    334                /* oC = ((A10/1024)*1500mV)-986mV)*1/3.55mV = A10*423/1024 - 278
    335                 * the temperature is transmitted as an integer where 32.1 = 321
    336                 * hence 4230 instead of 423
    337                 */
    338                temp = results[0];
    339                degC = ((temp - 673) * 4230) / 1024;
    340                if( (*tempOffset) != 0xFFFF )
    341                {
    342                  degC += (*tempOffset);
    343                }
    344          
    345                temp = results[1];
    346                volt = (temp*25)/512;
    347          
    348                //MESN this is arbitrary scaling towards a 0-127 range for ASCII conversion
    349                //TODO: move to ED
    350                //temp = (results[2] - 500)/6;
    351                temp = results[2];
    352                if(temp > 1000) //'on' cutoff point
    353                {
    354                  bend = '1';
    355                }else{
    356                  bend = '0';
    357                }
    358                /* Package up the data */
    359                msg[0] = degC&0xFF;
    360                msg[1] = (degC>>8)&0xFF;
    361                msg[2] = volt;
    362                msg[3] = bend;
    363                msg[4] = 'b';
    364                msg[5] = 'c';
    365                msg[6] = 'd';
    366          
    367                /* Send it over serial port */
    368                transmitDataString(1, addr, rssi, msg );
    369          
    370                BSP_TOGGLE_LED1();
    371          
    372                /* Done with measurement, disable measure flag */
    373                sSelfMeasureSem = 0;
    374              }
    375          
    376              /* Have we received a frame on one of the ED connections?
    377               * No critical section -- it doesn't really matter much if we miss a poll
    378               */
    379              if (sPeerFrameSem)
    380              {
    381                uint8_t     msg[MAX_APP_PAYLOAD], len, i;
    382          
    383                /* process all frames waiting */
    384                for (i=0; i<sNumCurrentPeers; ++i)
    385                {
    386                  if (SMPL_SUCCESS == SMPL_Receive(sLID[i], msg, &len))
    387                  {
    388                    ioctlRadioSiginfo_t sigInfo;
    389          
    390                    processMessage(sLID[i], msg, len);
    391          
    392                    sigInfo.lid = sLID[i];
    393          
    394                    SMPL_Ioctl(IOCTL_OBJ_RADIO, IOCTL_ACT_RADIO_SIGINFO, (void *)&sigInfo);
    395          
    396                    transmitData( i, sigInfo.sigInfo.rssi, (char*)msg );
    397                    BSP_TOGGLE_LED2();
    398          
    399                    BSP_ENTER_CRITICAL_SECTION(intState);
    400                    sPeerFrameSem--;
    401                    BSP_EXIT_CRITICAL_SECTION(intState);
    402                  }
    403                }
    404              }
    405              if (BSP_BUTTON1())
    406              {
    407                __delay_cycles(2000000);  /* debounce (0.25 seconds) */
    408                changeChannel();
    409              }
    410              else
    411              {
    412                checkChangeChannel();
    413              }
    414              BSP_ENTER_CRITICAL_SECTION(intState);
    415              if (sBlinky)
    416              {
    417                if (++sBlinky >= 0xF)
    418                {
    419                  sBlinky = 1;
    420                  BSP_TOGGLE_LED1();
    421                  BSP_TOGGLE_LED2();
    422                }
    423              }
    424              BSP_EXIT_CRITICAL_SECTION(intState);
    425            }
    426          
    427          }
    428          
    429          /* Runs in ISR context. Reading the frame should be done in the */
    430          /* application thread not in the ISR thread. */
    431          static uint8_t sCB(linkID_t lid)
    432          {
    433            if (lid)
    434            {
    435              sPeerFrameSem++;
    436              sBlinky = 0;
    437            }
    438            else
    439            {
    440              sJoinSem++;
    441            }
    442          
    443            /* leave frame to be read by application. */
    444            return 0;
    445          }
    446          
    447          static void processMessage(linkID_t lid, uint8_t *msg, uint8_t len)
    448          {
    449            /* do something useful */
    450            if (len)
    451            {
    452              BSP_TOGGLE_LED1();
    453            }
    454            return;
    455          }
    456          
    457          static void changeChannel(void)
    458          {
    459          #ifdef FREQUENCY_AGILITY
    460            freqEntry_t freq;
    461          
    462            if (++sChannel >= NWK_FREQ_TBL_SIZE)
    463            {
    464              sChannel = 0;
    465            }
    466            freq.logicalChan = sChannel;
    467            SMPL_Ioctl(IOCTL_OBJ_FREQ, IOCTL_ACT_SET, &freq);
    468            BSP_TURN_OFF_LED1();
    469            BSP_TURN_OFF_LED2();
    470            sBlinky = 1;
    471          #endif
    472            return;
    473          }
    474          
    475          /* implement auto-channel-change policy here... */
    476          static void checkChangeChannel(void)
    477          {
    478          #ifdef FREQUENCY_AGILITY
    479            int8_t dbm, inARow = 0;
    480          
    481            uint8_t i;
    482          
    483            memset(sSample, 0x0, SSIZE);
    484            for (i=0; i<SSIZE; ++i)
    485            {
    486              /* quit if we need to service an app frame */
    487              if (sPeerFrameSem || sJoinSem)
    488              {
    489                return;
    490              }
    491              NWK_DELAY(1);
    492              SMPL_Ioctl(IOCTL_OBJ_RADIO, IOCTL_ACT_RADIO_RSSI, (void *)&dbm);
    493              sSample[i] = dbm;
    494          
    495              if (dbm > INTERFERNCE_THRESHOLD_DBM)
    496              {
    497                if (++inARow == IN_A_ROW)
    498                {
    499                  changeChannel();
    500                  break;
    501                }
    502              }
    503              else
    504              {
    505                inARow = 0;
    506              }
    507            }
    508          #endif
    509            return;
    510          }
    511          
    512          /*------------------------------------------------------------------------------
    513          * ADC10 interrupt service routine
    514          ------------------------------------------------------------------------------*/
    515          #pragma vector=ADC10_VECTOR
    516          __interrupt void ADC10_ISR(void)
    517          {
    518            __bic_SR_register_on_exit(CPUOFF);        // Clear CPUOFF bit from 0(SR)
    519          }
    520          
    521          /*------------------------------------------------------------------------------
    522          * Timer A0 interrupt service routine
    523          ------------------------------------------------------------------------------*/
    524          #pragma vector=TIMERA0_VECTOR
    525          __interrupt void Timer_A (void)
    526          {
    527            sSelfMeasureSem = 1;
    528          }

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   ADC10_ISR
      4   Timer_A
     36   main
       36   -> BSP_Init
       36   -> COM_Init
       36   -> SMPL_Init
       36   -> SMPL_Ioctl
       36   -> SMPL_LinkListen
       36   -> SMPL_Receive
       36   -> TXString
       36   -> transmitData
       36   -> transmitDataString
       36 ?DivMod32s
       36 ?Mul32
      2   sCB


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant "000">
       7  ?<Constant "Done\r\n">
       5  ?<Constant "HUB0">
      27  ?<Constant "\r\nInitializing Networ...">
       2  ?<Initializer for tempOffset>
      24  ?Subroutine0
       2  ADC10CTL0
       2  ADC10CTL1
       2  ADC10MEM
       8  ADC10_ISR
       2  ADC10_ISR::??INTVEC 10
       1  BCSCTL3
       1  P1IN
       1  P1OUT
       2  TACCR0
       2  TACCTL0
       2  TACTL
       6  Timer_A
       2  Timer_A::??INTVEC 18
     670  main
       1  sBlinky
      22  sCB
       1  sJoinSem
       8  sLID
       1  sNumCurrentPeers
       1  sPeerFrameSem
       1  sSelfMeasureSem
     339  splash
       2  tempOffset

 
 730 bytes in segment CODE
  15 bytes in segment DATA16_AN
 382 bytes in segment DATA16_C
   2 bytes in segment DATA16_I
   2 bytes in segment DATA16_ID
  13 bytes in segment DATA16_Z
   4 bytes in segment INTVEC
 
 730 bytes of CODE  memory
 384 bytes of CONST memory (+  4 bytes shared)
  15 bytes of DATA  memory (+ 15 bytes shared)

Errors: none
Warnings: none
